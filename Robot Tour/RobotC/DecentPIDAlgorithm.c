#pragma config(Sensor, I2C_1,  rightMotorEncoder, sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  leftMotorEncoder, sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,  rightMotor,     tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port3,  leftMotor,     tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const float wheelDiameter = 2.75; // Wheel diameter in inches
const float cmToInch = 2.54; // Conversion factor from cm to inches
const float cmToEncoderTicks = (627.2 / (wheelDiameter * cmToInch * 3.14159265)); // Calculate encoder ticks per cm

void forward(float distance) {
	writeDebugStreamLine("STARTING");
  int targetEncoderValue = distance * cmToEncoderTicks;
  writeDebugStreamLine("target %d", targetEncoderValue);
  int power = 63; // Adjust this value as needed
  int stoppingThreshold = 10; // Threshold for stopping

  // PID constants (adjust these values)
	const float Kp = .6; //proportional gain
	const float Ki = 0; // Integral gain
	const float Kd = 0; // Derivative gain

	// Variables for PID control
	float previousError = 0.0;
	float integral = 0.0;



  while (true) {
    int leftEncoderValue = -getMotorEncoder(leftMotor); // Get left encoder value
    int rightEncoderValue = -getMotorEncoder(rightMotor); // Get right encoder value

    // Calculate the difference in encoder values for drift correction
    int encoderDifference = leftEncoderValue - rightEncoderValue;
		writeDebugStreamLine("Encoder Distance: %d", encoderDifference);

    // Calculate PID error
    float error = targetEncoderValue - leftEncoderValue;

    // Calculate PID components
    float proportional = Kp * error;
    integral += Ki * error;
    float derivative = Kd * (error - previousError);

    // Calculate PID output
    float PID_output = proportional + integral + derivative;

    // Update previous error
    previousError = error;

    // Adjust motor speeds with PID control
    motor[leftMotor] = power + PID_output;
    motor[rightMotor] = power + PID_output;

		writeDebugStreamLine("Right Encoder: %d", nMotorEncoder[rightMotor]);
    writeDebugStreamLine("Left Encoder: %d", nMotorEncoder[leftMotor]);

    // Check if both encoders are close to the target value
    if ((targetEncoderValue - leftEncoderValue) < stoppingThreshold && (targetEncoderValue - rightEncoderValue) < stoppingThreshold) {
      motor[rightMotor] = 0;
      motor[leftMotor] = 0;
      break; // Exit the loop when both motors are close to the target
    }
    delay(50);
  }
}


task main()
{
    // Reset the encoders
    nMotorEncoder[rightMotor] = 0;
    nMotorEncoder[leftMotor] = 0;
		forward(10);

    while(true)
    {
        // Display the encoder values
        writeDebugStreamLine("Done Right Encoder: %d", nMotorEncoder[rightMotor]);
        writeDebugStreamLine("Done Left Encoder: %d", nMotorEncoder[leftMotor]);

        // Small delay to make the output readable
        wait1Msec(1000);
    }
}
