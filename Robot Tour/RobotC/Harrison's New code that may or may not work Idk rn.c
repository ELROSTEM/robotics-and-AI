#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  rightMotorEncoder, sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  leftMotorEncoder, sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           rightMotor,    tmotorVex393_MC29, openLoop, driveLeft, encoderPort, I2C_1)
#pragma config(Motor,  port3,           leftMotor,     tmotorVex393_MC29, openLoop, reversed, driveRight, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const float wheelDiameter = 4; // Wheel diameter in inches
const float cmToInch = 2.54; // Conversion factor from cm to inches
const float cmToEncoderTicks = (627.2 / (wheelDiameter * cmToInch * 3.14159265)); // Calculate encoder ticks per cm
const float EncoderTicksToCm = 1 / cmToEncoderTicks;
int prevTargetEncoderValue = 0;
bool waitUntilTurn = true;

void forward(float distance);
void turnRight(int turns);
void turnLeft(int turns);
int calculateTurnEncoderValue(int degrees);

task main()
{
    // Reset the encoders

		/* Calculate deceleration time
		clearTimer(T2);
		int initialLeftCount = nMotorEncoder[leftMotor];
		int initialRightCount = nMotorEncoder[rightMotor];
		int threshold = 5;
		bool leftStopped = false;
		bool rightStopped = false;

		while (!leftStopped || !rightStopped) { // While either motor is moving
			wait1Msec(10);

			if (!leftStopped) { // Checks every loop if the left motor stopped
				int currentLeftCount = nMotorEncoder[leftMotor];
				if (abs(currentLeftCount - initialLeftCount) <= threshold) {
					leftStopped = true;
				}
				initialLeftCount = currentLeftCount;
			}
			if (!rightStopped) { // Checks every loop if the right motor stopped
				int currentRightCount = nMotorEncoder[rightMotor];
				if (abs(currentRightCount - initialRightCount) <= threshold) {
					rightStopped = true;
				}
				initialRightCount = currentRightCount;
			}
		}

		int decelerationTime = time1[T2];
		writeDebugStreamLine("Final right: %d. Final left: %d. Deceleration Time: %d",
												nMotorEncoder[rightMotor], nMotorEncoder[leftMotor], decelerationTime);
		writeDebugStreamLine("Final right: %d. Final left: %d. Deceleration Time: %d",
												nMotorEncoder[rightMotor] * EncoderTicksToCm, nMotorEncoder[leftMotor] * EncoderTicksToCm, decelerationTime);*/

		forward(50);
		turnRight(1)
}

void forward(float distance) {
		if (waitUntilTurn == true){
			nMotorEncoder[rightMotor] = 0;
	    nMotorEncoder[leftMotor] = 0;
	    writeDebugStreamLine("\nMoving Forward");

	    int targetEncoderValue = distance * cmToEncoderTicks; // May want to make a target left / right encoder
	    writeDebugStreamLine("Target encoder value: %d", targetEncoderValue);
	    int basePower = 127; // Base power for the motors (original was 63)

	    // PID constants
	    const float Kp = 12; // Proportional gain, adjust as necessary
	    // Integral and Derivative gains are set to 0 for now, focus on tuning Kp first

	    clearTimer(T1);
	    while (true) {
		        int leftEncoderValue = getMotorEncoder(leftMotor);
		        int rightEncoderValue = getMotorEncoder(rightMotor);

		        // Calculate the drift error (difference in encoder values)
		        int driftError = rightEncoderValue - leftEncoderValue;

		        // Proportional control for drift correction
		        int correction = Kp * driftError;

		        // Apply correction asymmetrically
		        motor[leftMotor] = basePower - correction; // Decrease speed if left motor is ahead
		        motor[rightMotor] = basePower + correction; // Increase speed if left motor is ahead

		        writeDebugStreamLine("Right: %d. Left: %d. Difference: %d Correction: %d", rightEncoderValue, leftEncoderValue, driftError, correction);

		        // Exit condition: when the target distance is reached
		        if (abs(leftEncoderValue) >= targetEncoderValue && abs(rightEncoderValue) >= targetEncoderValue) {
		            motor[rightMotor] = 0;
		            motor[leftMotor] = 0;
		            waitUntilTurn = false;
		            //writeDebugStreamLine("Finish time: %d", time1[T1]);

		            break;
		        }

		        wait1Msec(10);
		    }
		}
}

int calculateTurnEncoderValue(int degrees) {
	const float wheelSeperation = 15.5;
	const float turnDistance = 3.141592 * wheelSeperation / (360/degrees);
	return turnDistance * cmToEncoderTicks;
}

void turnLeft(int turns) {
    int targetEncoderValue = calculateTurnEncoderValue(90 * turns); // Target encoder value for the turn
    nMotorEncoder[rightMotor] = 0;
    nMotorEncoder[leftMotor] = 0;
    writeDebugStreamLine("\nTurning Left");

    // PID constants
    const float Kp = 0.5; // Proportional gain, adjust as necessary
    const float Ki = 0;  // Integral gain, set to 0 for now
    const float Kd = 0;  // Derivative gain, set to 0 for now

    while (true) {
    		waitUntilTurn = false;
        int leftEncoderValue = getMotorEncoder(leftMotor);
        int rightEncoderValue = getMotorEncoder(rightMotor);

        // Calculate the drift error (difference in encoder values)
        int driftError = leftEncoderValue + rightEncoderValue; // Adjusted for turning right

        // Proportional control for drift correction
        int correction = Kp * driftError;

        // Apply correction asymmetrically
        motor[rightMotor] = 60 - correction;  // Adjust speed of left motor
        motor[leftMotor] = -60 + correction; // Adjust speed of right motor (note the negative sign)

		    writeDebugStreamLine("Right: %d. Left: %d. Difference: %d Correction: %d", rightEncoderValue, leftEncoderValue, driftError, correction);

        // Exit condition: when the target turn is reached
        if (abs(rightEncoderValue) >= targetEncoderValue && abs(leftEncoderValue) >= targetEncoderValue) {
            motor[rightMotor] = 0;
            motor[leftMotor] = 0;
            waitUntilTurn = true;
            break;
        }

        wait1Msec(10);
    }
}


void turnRight(int turns) {
		waitUntilTurn = false;
    int targetEncoderValue = calculateTurnEncoderValue(90 * turns); // Target encoder value for the turn
    nMotorEncoder[rightMotor] = 0;
    nMotorEncoder[leftMotor] = 0;
    writeDebugStreamLine("\nTurning Right");
    writeDebugStreamLine("%d", targetEncoderValue);

    // PID constants
    const float Kp = 0.5; // Proportional gain, adjust as necessary

    while (true) {
        int leftEncoderValue = getMotorEncoder(leftMotor);
        int rightEncoderValue = getMotorEncoder(rightMotor);

        // Calculate the drift error (difference in encoder values)
        int driftError = leftEncoderValue + rightEncoderValue; // Adjusted for turning right

        // Proportional control for drift correction
        int correction = Kp * driftError;

        // Apply correction asymmetrically
        motor[leftMotor] = 60 - correction;  // Adjust speed of left motor
        motor[rightMotor] = -60 + correction; // Adjust speed of right motor (note the negative sign)

				writeDebugStreamLine("Right: %d. Left: %d. Difference: %d Correction: %d", rightEncoderValue, leftEncoderValue, driftError, correction);

        // Exit condition: when the target turn is reached
        if (abs(leftEncoderValue) >= targetEncoderValue && abs(rightEncoderValue) >= targetEncoderValue) {
            motor[rightMotor] = 0;
            motor[leftMotor] = 0;
            writeDebugStreamLine("Right: %d. Left: %d. Difference: %d Correction: %d", rightEncoderValue, leftEncoderValue, driftError, correction);
            waitUntilTurn = true;
            break;
        }

        wait1Msec(10);
    }
}
