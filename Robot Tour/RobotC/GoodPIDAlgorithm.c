#pragma config(Sensor, I2C_1,  rightMotorEncoder, sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  leftMotorEncoder, sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,  rightMotor,     tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port3,  leftMotor,     tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const float wheelDiameter = 2.75; // Wheel diameter in inches
const float cmToInch = 2.54; // Conversion factor from cm to inches
const float cmToEncoderTicks = (627.2 / (wheelDiameter * cmToInch * 3.14159265)); // Calculate encoder ticks per cm

void forward(float distance) {
    writeDebugStreamLine("STARTING");
    int targetEncoderValue = distance * cmToEncoderTicks;
    writeDebugStreamLine("target %d", targetEncoderValue);
    int basePower = 63; // Base power for the motors

    // PID constants
    const float Kp = 0.85; // Proportional gain, adjust as necessary
    // Integral and Derivative gains are set to 0 for now, focus on tuning Kp first
    const float Ki = 0;
    const float Kd = 0;

    while (true) {
        int leftEncoderValue = getMotorEncoder(leftMotor);
        int rightEncoderValue = getMotorEncoder(rightMotor);

        // Calculate the drift error (difference in encoder values)
        int driftError = rightEncoderValue - leftEncoderValue;

        // Proportional control for drift correction
        int correction = Kp * driftError;

        // Apply correction asymmetrically
        motor[leftMotor] = basePower - correction; // Decrease speed if left motor is ahead
        motor[rightMotor] = basePower + correction; // Increase speed if left motor is ahead

        writeDebugStreamLine("Right Encoder: %d", rightEncoderValue);
        writeDebugStreamLine("Left Encoder: %d", leftEncoderValue);
        writeDebugStreamLine("Encoder Distance: %d", driftError);

        // Exit condition: when the target distance is reached
        if (abs(leftEncoderValue) >= targetEncoderValue && abs(rightEncoderValue) >= targetEncoderValue) {
            motor[rightMotor] = 0;
            motor[leftMotor] = 0;
            break;
        }

        wait1Msec(50);
    }
}



task main()
{
    // Reset the encoders
    nMotorEncoder[rightMotor] = 0;
    nMotorEncoder[leftMotor] = 0;
		forward(50);

    while(true)
    {
        // Display the encoder values
        writeDebugStreamLine("Done Right Encoder: %d", nMotorEncoder[rightMotor]);
        writeDebugStreamLine("Done Left Encoder: %d", nMotorEncoder[leftMotor]);

        // Small delay to make the output readable
        wait1Msec(1000);
    }
}
